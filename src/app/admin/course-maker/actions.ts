
'use server';

import { createClient } from '@/lib/supabase/server';
import { revalidatePath } from 'next/cache';
import { cookies } from 'next/headers';
import fs from 'fs/promises';
import path from 'path';
import type { Lesson, Subtopic, PracticeQuestion } from '@/lib/types';
import { z } from 'zod';

const subtopicSchema = z.object({
  id: z.string(),
  title: z.string().min(5, "Title is required."),
  content: z.string().min(50, "Content must be at least 50 characters."),
  ai_summary: z.string().min(20, "AI Summary is required."),
  practice_questions: z.array(z.object({
    id: z.string(),
    type: z.enum(['mcq', 'text']),
    question: z.string().min(5, "Question text is required."),
    options: z.array(z.string()).optional(),
    answer: z.string().min(1, "Answer is required."),
  })).min(1, "At least one practice question is required."),
});

const courseFormSchema = z.object({
  title: z.string().min(5, "Course title is required."),
  description: z.string().min(20, "Course description is required."),
  is_free: z.boolean().default(false),
  subtopics: z.array(subtopicSchema),
});


type CourseFormValues = z.infer<typeof courseFormSchema>;


async function verifyAdmin() {
    const cookieStore = cookies();
    const supabase = createClient(cookieStore);
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('Authentication required.');

    const { data: profile } = await supabase.from('profiles').select('role').eq('id', user.id).single();
    if (profile?.role !== 'admin') throw new Error('Permission denied. You must be an admin.');
    
    return user;
}


// IMPORTANT: This approach of writing to the file system will not work in a serverless environment.
const contentFilePath = path.join(process.cwd(), 'src/data', 'sample-content.json');

async function readContentFile(): Promise<{lessons: Lesson[], subtopics: Subtopic[]}> {
    try {
        const fileContent = await fs.readFile(contentFilePath, 'utf-8');
        return JSON.parse(fileContent);
    } catch (error) {
        console.error("Failed to read content file:", error);
        return { lessons: [], subtopics: [] };
    }
}

async function writeContentFile(data: {lessons: Lesson[], subtopics: Subtopic[]}): Promise<void> {
    await fs.writeFile(contentFilePath, JSON.stringify(data, null, 2), 'utf-8');
}


export async function createFullCourseAction(values: CourseFormValues): Promise<{success: boolean, error?: string}> {
  try {
    await verifyAdmin();

    const validatedData = courseFormSchema.parse(values);

    const content = await readContentFile();
    
    // Find the highest existing lesson ID and order_index
    const maxLessonId = content.lessons.reduce((max, l) => Math.max(max, parseInt(l.id!)), 0);
    const maxLessonOrder = content.lessons.reduce((max, l) => Math.max(max, l.order_index), 0);
    
    const newLessonId = (maxLessonId + 1).toString();

    const newLesson: Lesson = {
        id: newLessonId,
        title: validatedData.title,
        description: validatedData.description,
        is_free: validatedData.is_free,
        order_index: maxLessonOrder + 1,
        subtopics: [], // subtopics are stored separately
    };

    const newSubtopics: Subtopic[] = validatedData.subtopics.map((sub, index) => ({
        id: `${newLessonId}-${index + 1}`,
        lesson_id: newLessonId,
        title: sub.title,
        content: sub.content,
        order_index: index + 1,
        video_url: '', // Video URL is not generated by this flow
        ai_summary: sub.ai_summary,
        practice_questions: sub.practice_questions.map((q, qIndex) => ({
            id: `q${qIndex + 1}`,
            type: q.type,
            question: q.question,
            options: q.options,
            answer: q.answer,
        })),
    }));

    content.lessons.push(newLesson);
    content.subtopics.push(...newSubtopics);

    await writeContentFile(content);
    
    revalidatePath('/lessons', 'layout');
    revalidatePath('/admin/content');
    revalidatePath('/admin/course-maker');
    
    return { success: true };

  } catch (error: any) {
    console.error('An unexpected error occurred in createFullCourseAction:', error);
    if (error instanceof z.ZodError) {
        return { success: false, error: 'Invalid data provided. Please check the form.' };
    }
    return { success: false, error: error.message || 'An unexpected server error occurred.' };
  }
}
